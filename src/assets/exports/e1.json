{"vertexShader":"varying vec2 vUv;\nuniform vec2 viewport;\nuniform float time;\nuniform sampler2D uTFeedback_1710_1770;\nuniform int uSteps_1775;\nuniform float uAdd_1774;\nuniform float uMult_1774;\nuniform int uStepsZ_1713;\nuniform float uFrequency_1712;\nuniform float uAmplitude_1712;\nuniform float uPersistance_1712;\nuniform float uLacunarity_1712;\nuniform int uOctaves_1712;\nuniform float uExponent_1712;\nuniform float uRidge_1712;\nuniform bool uNormalize_1712;\nuniform float uAdd_1746;\nuniform float uMult_1746;\nuniform int uStepsZ_1706;\nuniform sampler2D uTFeedback_1710;\nuniform float uAdd_1750;\nuniform float uMult_1750;\nuniform float uFrequency_1703;\nuniform float uAmplitude_1703;\nuniform float uPersistance_1703;\nuniform float uLacunarity_1703;\nuniform int uOctaves_1703;\nuniform float uExponent_1703;\nuniform float uRidge_1703;\nuniform bool uNormalize_1703;\nuniform float uFrequency_1741;\nuniform float uAmplitude_1741;\nuniform float uPersistance_1741;\nuniform float uLacunarity_1741;\nuniform int uOctaves_1741;\nuniform float uExponent_1741;\nuniform float uRidge_1741;\nuniform bool uNormalize_1741;\nuniform int uOperation_1742;\nuniform int uSteps_1707;\nuniform float uAdd_1748;\nuniform float uMult_1748;\nuniform float uMin_1749;\nuniform float uMax_1749;\nuniform float uFrequency_1703_1708;\nuniform float uAmplitude_1703_1708;\nuniform float uPersistance_1703_1708;\nuniform float uLacunarity_1703_1708;\nuniform int uOctaves_1703_1708;\nuniform float uExponent_1703_1708;\nuniform float uRidge_1703_1708;\nuniform bool uNormalize_1703_1708;\nuniform int uOperation_1742_1742;\nuniform float uAngle2_1705;\nuniform float uX_1702;\nuniform float uY_1702;\nuniform float uZ_1702;\nuniform float uAmount_1702;\nuniform float uFrequency_1699;\nuniform float uXAmount_1699;\nuniform float uYAmount_1699;\nuniform float uZAmount_1699;\nuniform float uMin_1699;\nuniform float uMax_1699;\nuniform float uPower_1699;\nuniform float uFrequency_1699_1699;\nuniform float uXAmount_1699_1699;\nuniform float uYAmount_1699_1699;\nuniform float uZAmount_1699_1699;\nuniform float uMin_1699_1699;\nuniform float uMax_1699_1699;\nuniform float uPower_1699_1699;\nuniform int uOperation_1701;\nuniform float uAdd_1704;\nuniform float uMult_1704;\nuniform float uContrast_1745;\nuniform float uBrightness_1745;\nuniform float uAmount_1711;\nuniform int uOperation_1751;\nuniform float uDithering_1695;\nuniform float uScale_1695;\nuniform float uSpeedX_1695;\nuniform float uSpeedY_1695;\nuniform float uSpeedZ_1695;\nuniform vec2 uDitheringTextureDimensions_1695;\nuniform sampler2D uTDithering_1695;\n\n\n\n\n\nvoid main() {\n  vUv = uv;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}","fragmentShader":"varying vec2 vUv;\nuniform vec2 viewport;\nuniform float time;\nuniform sampler2D uTFeedback_1710_1770;\nuniform int uSteps_1775;\nuniform float uAdd_1774;\nuniform float uMult_1774;\nuniform int uStepsZ_1713;\nuniform float uFrequency_1712;\nuniform float uAmplitude_1712;\nuniform float uPersistance_1712;\nuniform float uLacunarity_1712;\nuniform int uOctaves_1712;\nuniform float uExponent_1712;\nuniform float uRidge_1712;\nuniform bool uNormalize_1712;\nuniform float uAdd_1746;\nuniform float uMult_1746;\nuniform int uStepsZ_1706;\nuniform sampler2D uTFeedback_1710;\nuniform float uAdd_1750;\nuniform float uMult_1750;\nuniform float uFrequency_1703;\nuniform float uAmplitude_1703;\nuniform float uPersistance_1703;\nuniform float uLacunarity_1703;\nuniform int uOctaves_1703;\nuniform float uExponent_1703;\nuniform float uRidge_1703;\nuniform bool uNormalize_1703;\nuniform float uFrequency_1741;\nuniform float uAmplitude_1741;\nuniform float uPersistance_1741;\nuniform float uLacunarity_1741;\nuniform int uOctaves_1741;\nuniform float uExponent_1741;\nuniform float uRidge_1741;\nuniform bool uNormalize_1741;\nuniform int uOperation_1742;\nuniform int uSteps_1707;\nuniform float uAdd_1748;\nuniform float uMult_1748;\nuniform float uMin_1749;\nuniform float uMax_1749;\nuniform float uFrequency_1703_1708;\nuniform float uAmplitude_1703_1708;\nuniform float uPersistance_1703_1708;\nuniform float uLacunarity_1703_1708;\nuniform int uOctaves_1703_1708;\nuniform float uExponent_1703_1708;\nuniform float uRidge_1703_1708;\nuniform bool uNormalize_1703_1708;\nuniform int uOperation_1742_1742;\nuniform float uAngle2_1705;\nuniform float uX_1702;\nuniform float uY_1702;\nuniform float uZ_1702;\nuniform float uAmount_1702;\nuniform float uFrequency_1699;\nuniform float uXAmount_1699;\nuniform float uYAmount_1699;\nuniform float uZAmount_1699;\nuniform float uMin_1699;\nuniform float uMax_1699;\nuniform float uPower_1699;\nuniform float uFrequency_1699_1699;\nuniform float uXAmount_1699_1699;\nuniform float uYAmount_1699_1699;\nuniform float uZAmount_1699_1699;\nuniform float uMin_1699_1699;\nuniform float uMax_1699_1699;\nuniform float uPower_1699_1699;\nuniform int uOperation_1701;\nuniform float uAdd_1704;\nuniform float uMult_1704;\nuniform float uContrast_1745;\nuniform float uBrightness_1745;\nuniform float uAmount_1711;\nuniform int uOperation_1751;\nuniform float uDithering_1695;\nuniform float uScale_1695;\nuniform float uSpeedX_1695;\nuniform float uSpeedY_1695;\nuniform float uSpeedZ_1695;\nuniform vec2 uDitheringTextureDimensions_1695;\nuniform sampler2D uTDithering_1695;\n\n  vec3 rgbToHsv(vec3 rgb) {\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(rgb.bg, K.wz), vec4(rgb.gb, K.xy), step(rgb.b, rgb.g));\n    vec4 q = mix(vec4(p.xyw, rgb.r), vec4(rgb.r, p.yzx), step(p.x, rgb.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n  }\n\n//\tSimplex 3D Noise \n//\tby Ian McEwan, Ashima Arts\n//\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\n\nfloat simplex3d(vec3 v){ \n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //  x0 = x0 - 0. + 0.0 * C \n  vec3 x1 = x0 - i1 + 1.0 * C.xxx;\n  vec3 x2 = x0 - i2 + 2.0 * C.xxx;\n  vec3 x3 = x0 - 1. + 3.0 * C.xxx;\n\n// Permutations\n  i = mod(i, 289.0 ); \n  vec4 p = permute( permute( permute( \n            i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n          + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n          + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients\n// ( N*N points uniformly over a square, mapped onto an octahedron.)\n  float n_ = 1.0/7.0; // N=7\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  float n = 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                dot(p2,x2), dot(p3,x3) ) );\n\n  n = ( n + 1.0 ) / 2.0;\n  return clamp( n, 0.0, 1.0 );\n}\n\n\nvoid FAST32_hash_3D( \tvec3 gridcell,\n                        out vec4 lowz_hash_0,\n                        out vec4 lowz_hash_1,\n                        out vec4 lowz_hash_2,\n                        out vec4 highz_hash_0,\n                        out vec4 highz_hash_1,\n                        out vec4 highz_hash_2\t)\t\t//\tgenerates 3 random numbers for each of the 8 cell corners\n{\n    //    gridcell is assumed to be an integer coordinate\n\n    //\tTODO: \tthese constants need tweaked to find the best possible noise.\n    //\t\t\tprobably requires some kind of brute force computational searching or something....\n    const vec2 OFFSET = vec2( 50.0, 161.0 );\n    const float DOMAIN = 69.0;\n    const vec3 SOMELARGEFLOATS = vec3( 635.298681, 682.357502, 668.926525 );\n    const vec3 ZINC = vec3( 48.500388, 65.294118, 63.934599 );\n\n    //\ttruncate the domain\n    gridcell.xyz = gridcell.xyz - floor(gridcell.xyz * ( 1.0 / DOMAIN )) * DOMAIN;\n    vec3 gridcell_inc1 = step( gridcell, vec3( DOMAIN - 1.5 ) ) * ( gridcell + 1.0 );\n\n    //\tcalculate the noise\n    vec4 P = vec4( gridcell.xy, gridcell_inc1.xy ) + OFFSET.xyxy;\n    P *= P;\n    P = P.xzxz * P.yyww;\n    vec3 lowz_mod = vec3( 1.0 / ( SOMELARGEFLOATS.xyz + gridcell.zzz * ZINC.xyz ) );\n    vec3 highz_mod = vec3( 1.0 / ( SOMELARGEFLOATS.xyz + gridcell_inc1.zzz * ZINC.xyz ) );\n    lowz_hash_0 = fract( P * lowz_mod.xxxx );\n    highz_hash_0 = fract( P * highz_mod.xxxx );\n    lowz_hash_1 = fract( P * lowz_mod.yyyy );\n    highz_hash_1 = fract( P * highz_mod.yyyy );\n    lowz_hash_2 = fract( P * lowz_mod.zzzz );\n    highz_hash_2 = fract( P * highz_mod.zzzz );\n}\n\n  //\tconvert a 0.0->1.0 sample to a -1.0->1.0 sample weighted towards the extremes\nvec4 Cellular_weight_samples( vec4 samples )\n{\n    samples = samples * 2.0 - 1.0;\n    //return (1.0 - samples * samples) * sign(samples);\t// square\n    return (samples * samples * samples) - sign(samples);\t// cubic (even more variance)\n}\n\n//\n//\tCellular Noise 3D\n//\tBased off Stefan Gustavson's work at http://www.itn.liu.se/~stegu/GLSL-cellular\n//\thttp://briansharpe.files.wordpress.com/2011/12/cellularsample.jpg\n//\n//\tSpeed up by using 2x2x2 search window instead of 3x3x3\n//\tproduces range of 0.0->1.0\n//\nfloat fastVoronoi3d(vec3 P)\n{\n    //\testablish our grid cell and unit position\n    vec3 Pi = floor(P);\n    vec3 Pf = P - Pi;\n\n    //\tcalculate the hash.\n    //\t( various hashing methods listed in order of speed )\n    vec4 hash_x0, hash_y0, hash_z0, hash_x1, hash_y1, hash_z1;\n    FAST32_hash_3D( Pi, hash_x0, hash_y0, hash_z0, hash_x1, hash_y1, hash_z1 );\n    //SGPP_hash_3D( Pi, hash_x0, hash_y0, hash_z0, hash_x1, hash_y1, hash_z1 );\n\n    //\tgenerate the 8 random points\n#if 1\n    //\trestrict the random point offset to eliminate artifacts\n    //\twe'll improve the variance of the noise by pushing the points to the extremes of the jitter window\n    const float JITTER_WINDOW = 0.166666666;\t// 0.166666666 will guarentee no artifacts. It is the intersection on x of graphs f(x)=( (0.5 + (0.5-x))^2 + 2*((0.5-x)^2) ) and f(x)=( 2 * (( 0.5 + x )^2) + x * x )\n    hash_x0 = Cellular_weight_samples( hash_x0 ) * JITTER_WINDOW + vec4(0.0, 1.0, 0.0, 1.0);\n    hash_y0 = Cellular_weight_samples( hash_y0 ) * JITTER_WINDOW + vec4(0.0, 0.0, 1.0, 1.0);\n    hash_x1 = Cellular_weight_samples( hash_x1 ) * JITTER_WINDOW + vec4(0.0, 1.0, 0.0, 1.0);\n    hash_y1 = Cellular_weight_samples( hash_y1 ) * JITTER_WINDOW + vec4(0.0, 0.0, 1.0, 1.0);\n    hash_z0 = Cellular_weight_samples( hash_z0 ) * JITTER_WINDOW + vec4(0.0, 0.0, 0.0, 0.0);\n    hash_z1 = Cellular_weight_samples( hash_z1 ) * JITTER_WINDOW + vec4(1.0, 1.0, 1.0, 1.0);\n#else\n    //\tnon-weighted jitter window.  jitter window of 0.4 will give results similar to Stefans original implementation\n    //\tnicer looking, faster, but has minor artifacts.  ( discontinuities in signal )\n    const float JITTER_WINDOW = 0.4;\n    hash_x0 = hash_x0 * JITTER_WINDOW * 2.0 + vec4(-JITTER_WINDOW, 1.0-JITTER_WINDOW, -JITTER_WINDOW, 1.0-JITTER_WINDOW);\n    hash_y0 = hash_y0 * JITTER_WINDOW * 2.0 + vec4(-JITTER_WINDOW, -JITTER_WINDOW, 1.0-JITTER_WINDOW, 1.0-JITTER_WINDOW);\n    hash_x1 = hash_x1 * JITTER_WINDOW * 2.0 + vec4(-JITTER_WINDOW, 1.0-JITTER_WINDOW, -JITTER_WINDOW, 1.0-JITTER_WINDOW);\n    hash_y1 = hash_y1 * JITTER_WINDOW * 2.0 + vec4(-JITTER_WINDOW, -JITTER_WINDOW, 1.0-JITTER_WINDOW, 1.0-JITTER_WINDOW);\n    hash_z0 = hash_z0 * JITTER_WINDOW * 2.0 + vec4(-JITTER_WINDOW, -JITTER_WINDOW, -JITTER_WINDOW, -JITTER_WINDOW);\n    hash_z1 = hash_z1 * JITTER_WINDOW * 2.0 + vec4(1.0-JITTER_WINDOW, 1.0-JITTER_WINDOW, 1.0-JITTER_WINDOW, 1.0-JITTER_WINDOW);\n#endif\n\n    //\treturn the closest squared distance\n    vec4 dx1 = Pf.xxxx - hash_x0;\n    vec4 dy1 = Pf.yyyy - hash_y0;\n    vec4 dz1 = Pf.zzzz - hash_z0;\n    vec4 dx2 = Pf.xxxx - hash_x1;\n    vec4 dy2 = Pf.yyyy - hash_y1;\n    vec4 dz2 = Pf.zzzz - hash_z1;\n    vec4 d1 = dx1 * dx1 + dy1 * dy1 + dz1 * dz1;\n    vec4 d2 = dx2 * dx2 + dy2 * dy2 + dz2 * dz2;\n    d1 = min(d1, d2);\n    d1.xy = min(d1.xy, d1.wz);\n    return 2.0 * min(d1.x, d1.y) * ( 9.0 / 12.0 );\t//\tscale return value from 0.0->1.333333 to 0.0->1.0  \t(2/3)^2 * 3  == (12/9) == 1.333333\n}\n    \n  \n\nvec3 hsvToRgb(vec3 hsv) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(hsv.xxx + K.xyz) * 6.0 - K.www);\n  return hsv.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), hsv.y);\n}\n\n\nvec3 getFeedback( \n  vec3 point, float scale, sampler2D tFeedback\n) {\n  return texture2D(tFeedback, point.xy / (viewport * scale)).rgb;\n}\n\nfloat getBrightness( \n  vec3 source\n) {\n  return rgbToHsv(source).z;\n}\n\nfloat getQuantize( \n  float value, int steps\n) {\n  return round(value * float(steps)) / float(steps);\n}\n\nfloat getRemap( \n  float value, float add, float mult\n) {\n  return mult * value + add;\n}\n\nint getFloatToInt( \n  float value\n) {\n  return int(value);\n}\n\nvec3 getPixelate( \n  vec3 point, float scale, int stepsX, int stepsY, int stepsZ\n) {\n  float x = floor(point.x * float(stepsX)) / float(stepsX);\n  float y = floor(point.y * float(stepsY)) / float(stepsY);\n  float z = floor(point.z * float(stepsZ)) / float(stepsZ);\n  \n  return vec3(x, y, z);\n}\n\nfloat getSimplex( \n  vec3 point, float frequency, float amplitude, float persistance, float lacunarity, int octaves, float exponent, float ridge, bool normalize\n) {\n  float n = 0.0;\n  float f = frequency;\n  float a = amplitude;\n  float divider = 0.0;\n  \n  for(int i = 0; i < min(5, octaves); i++) {\n    vec3 p = point * f;\n    float on = pow(simplex3d(p), exponent);\n  \n    if(on > ridge) on = ridge - (on - ridge);\n    on /= ridge;\n  \n    n += a * on;\n  \n    divider += a;\n  \n    a *= persistance;\n    f *= lacunarity;\n  }\n  \n  if(normalize && divider != 0.0) { \n    n /= divider; \n  }\n  \n  return amplitude * n;\n}\n\nfloat getVoronoi( \n  vec3 point, float frequency, float amplitude, float persistance, float lacunarity, int octaves, float exponent, float ridge, bool normalize\n) {\n  float n = 0.0;\n  float f = frequency;\n  float a = amplitude;\n  float divider = 0.0;\n  \n  for(int i = 0; i < min(5, octaves); i++) {\n    vec3 p = point * f;\n    float on = pow(fastVoronoi3d(p), exponent);\n  \n    if(on > ridge) on = ridge - (on - ridge);\n    on /= ridge;\n  \n    n += a * on;\n  \n    divider += a;\n  \n    a *= persistance;\n    f *= lacunarity;\n  }\n  \n  if(normalize && divider != 0.0) { \n    n /= divider; \n  }\n  \n  return amplitude * n;\n}\n\nfloat getCombine( \n  int operation, float value1, float value2\n) {\n  if(operation == 0) {\n    return value1 + value2;\n  } else if(operation == 1) {\n    return value1 * value2;\n  } else if(operation == 2) {\n    return pow(value1, value2);\n  } else if(operation == 3) {\n    return (value1 + value2) / 2.0;\n  } else if(operation == 4) {\n    return mod(value1, value2);\n  }\n}\n\nfloat getClamp( \n  float value, float min, float max\n) {\n  return clamp(value, min, max);\n}\n\nvec3 getPolarDisplace( \n  vec3 point, float angle1, float angle2, float radius\n) {\n  float dx = radius * cos(angle1) * sin(angle2);\n  float dy = radius * sin(angle1) * cos(angle2);\n  float dz = radius * cos(angle2);\n  return point + vec3(dx, dy, dz);\n}\n\nvec3 getDisplace( \n  vec3 point, float x, float y, float z, float amount\n) {\n  return point + vec3(x, y, z) * amount;\n}\n\nfloat getWave( \n  vec3 point, float frequency, float xAmount, float yAmount, float zAmount, float min, float max, float power\n) {\n  \n      if(xAmount == 0.0 && yAmount == 0.0) return 0.0;\n  \n      float x = point.x * xAmount; \n      float y = point.y * yAmount;\n      float s = frequency * (x + y) / (abs(xAmount) + abs(yAmount));\n  \n      float v = sin(s);\n      v = (v + 1.0) / 2.0;\n      v = pow(v, power);\n  \n      return (max - min) * v + min;\n    \n}\n\nvec3 getHsvToRgb( \n  float hue, float saturation, float value\n) {\n  return hsvToRgb(vec3(hue, saturation, value));\n}\n\nvec3 getContrast( \n  vec3 source, float contrast, float brightness\n) {\n  return (source - 0.5) * contrast + 0.5 + brightness;\n}\n\nvec3 getLerp( \n  vec3 value1, vec3 value2, float amount\n) {\n  return mix(value1, value2, amount);\n}\n\nvec3 getColorCombine( \n  vec3 value1, vec3 value2, int operation\n) {\n  if(operation == 0) {\n    return value1 + value2;\n  } else if(operation == 1) {\n    return value1 * value2;\n  } else if(operation == 2) {\n    return pow(value1, value2);\n  } else if(operation == 3) {\n    return (value1 + value2) / 2.0;\n  } else if(operation == 4) {\n    return mod(value1, value2);\n  } else if(operation == 5) {\n    return hsvToRgb(value1).z > hsvToRgb(value2).z ? value1 : value2;\n  } else {\n    return hsvToRgb(value1).z < hsvToRgb(value2).z ? value1 : value2;\n  }\n}\n\nvec3 getRoot( \n  vec3 point, vec3 color, float dithering, vec2 ditheringTextureDimensions, sampler2D tDithering\n) {\n  vec2 ditheringCoord = gl_FragCoord.xy / ditheringTextureDimensions + vec2(fract(time * 13.41), fract(time * 3.451));\n  vec3 ditheringValue = dithering * texture(tDithering, ditheringCoord).rgb - dithering / 2.0;\n  return color + ditheringValue;\n}\n\nvoid main() {\n  vec3 point = vec3(gl_FragCoord.xy * uScale_1695, 0.0);\n  float scale = uScale_1695;\n  vec3 pointOffset = vec3(uSpeedX_1695, uSpeedY_1695, uSpeedZ_1695) * time;\n  point += pointOffset;\n  vec3 rFeedback_1710_1770 = getFeedback(point, scale, uTFeedback_1710_1770);\n  float rBrightness_1772 = getBrightness(rFeedback_1710_1770);\n  float rQuantize_1775 = getQuantize(rBrightness_1772, uSteps_1775);\n  float rRemap_1774 = getRemap(rQuantize_1775, uAdd_1774, uMult_1774);\n  int rFloatToInt_1773 = getFloatToInt(rRemap_1774);\n  vec3 rPixelate_1713 = getPixelate(point, scale, rFloatToInt_1773, rFloatToInt_1773, uStepsZ_1713);\n  float rSimplex_1712 = getSimplex(rPixelate_1713, uFrequency_1712, uAmplitude_1712, uPersistance_1712, uLacunarity_1712, uOctaves_1712, uExponent_1712, uRidge_1712, uNormalize_1712);\n  float rRemap_1746 = getRemap(rSimplex_1712, uAdd_1746, uMult_1746);\n  int rFloatToInt_1714 = getFloatToInt(rRemap_1746);\n  vec3 rPixelate_1706 = getPixelate(point, scale, rFloatToInt_1714, rFloatToInt_1714, uStepsZ_1706);\n  vec3 rFeedback_1710 = getFeedback(rPixelate_1706, scale, uTFeedback_1710);\n  float rBrightness_1744 = getBrightness(rFeedback_1710);\n  float rRemap_1750 = getRemap(rBrightness_1744, uAdd_1750, uMult_1750);\n  float rSimplex_1703 = getSimplex(rPixelate_1706, uFrequency_1703, uAmplitude_1703, uPersistance_1703, uLacunarity_1703, uOctaves_1703, uExponent_1703, uRidge_1703, uNormalize_1703);\n  float rVoronoi_1741 = getVoronoi(rPixelate_1706, uFrequency_1741, uAmplitude_1741, uPersistance_1741, uLacunarity_1741, uOctaves_1741, uExponent_1741, uRidge_1741, uNormalize_1741);\n  float rCombine_1742 = getCombine(uOperation_1742, rSimplex_1703, rVoronoi_1741);\n  float rQuantize_1707 = getQuantize(rCombine_1742, uSteps_1707);\n  float rRemap_1748 = getRemap(rQuantize_1707, uAdd_1748, uMult_1748);\n  float rClamp_1749 = getClamp(rRemap_1748, uMin_1749, uMax_1749);\n  float rSimplex_1703_1708 = getSimplex(rPixelate_1706, uFrequency_1703_1708, uAmplitude_1703_1708, uPersistance_1703_1708, uLacunarity_1703_1708, uOctaves_1703_1708, uExponent_1703_1708, uRidge_1703_1708, uNormalize_1703_1708);\n  float rCombine_1742_1742 = getCombine(uOperation_1742_1742, rSimplex_1703_1708, rVoronoi_1741);\n  vec3 rPolarDisplace_1705 = getPolarDisplace(point, rCombine_1742_1742, uAngle2_1705, rQuantize_1707);\n  vec3 rDisplace_1702 = getDisplace(rPolarDisplace_1705, uX_1702, uY_1702, uZ_1702, uAmount_1702);\n  float rWave_1699 = getWave(rDisplace_1702, uFrequency_1699, uXAmount_1699, uYAmount_1699, uZAmount_1699, uMin_1699, uMax_1699, uPower_1699);\n  float rWave_1699_1699 = getWave(rDisplace_1702, uFrequency_1699_1699, uXAmount_1699_1699, uYAmount_1699_1699, uZAmount_1699_1699, uMin_1699_1699, uMax_1699_1699, uPower_1699_1699);\n  float rCombine_1701 = getCombine(uOperation_1701, rWave_1699, rWave_1699_1699);\n  float rRemap_1704 = getRemap(rCombine_1701, uAdd_1704, uMult_1704);\n  vec3 rHsvToRgb_1696 = getHsvToRgb(rRemap_1750, rClamp_1749, rRemap_1704);\n  vec3 rContrast_1745 = getContrast(rHsvToRgb_1696, uContrast_1745, uBrightness_1745);\n  vec3 rLerp_1711 = getLerp(rFeedback_1710, rContrast_1745, uAmount_1711);\n  vec3 rColorCombine_1751 = getColorCombine(rLerp_1711, rContrast_1745, uOperation_1751);\n  vec3 rRoot_1695 = getRoot(point, rColorCombine_1751, uDithering_1695, uDitheringTextureDimensions_1695, uTDithering_1695);\n  vec4 result = vec4(rRoot_1695, 1.0);\n  gl_FragColor = result;\n}","uniforms":{"viewport":{"value":{"x":1920,"y":1080},"type":"vec2"},"time":{"value":5330.79896,"type":"float"},"uTFeedback_1710_1770":{"type":"sampler2D","value":{"metadata":{"version":4.5,"type":"Texture","generator":"Texture.toJSON"},"uuid":"05d3beba-2715-4cc8-ac23-058c8d7d8756","name":"","image":"652cb7e2-9488-4f83-9c0b-bd71ee3e5ca9","mapping":300,"repeat":[1,1],"offset":[0,0],"center":[0,0],"rotation":0,"wrap":[1002,1002],"format":1023,"type":1009,"encoding":3000,"minFilter":1006,"magFilter":1006,"anisotropy":1,"flipY":false,"premultiplyAlpha":false,"unpackAlignment":4}},"uSteps_1775":{"type":"int","value":10},"uAdd_1774":{"type":"float","value":0},"uMult_1774":{"type":"float","value":20},"uStepsZ_1713":{"type":"int","value":1000},"uFrequency_1712":{"type":"float","value":0.4},"uAmplitude_1712":{"type":"float","value":20},"uPersistance_1712":{"type":"float","value":0.5},"uLacunarity_1712":{"type":"float","value":2},"uOctaves_1712":{"type":"int","value":3},"uExponent_1712":{"type":"float","value":0.9091},"uRidge_1712":{"type":"float","value":0.15085},"uNormalize_1712":{"type":"bool","value":true},"uAdd_1746":{"type":"float","value":6.2},"uMult_1746":{"type":"float","value":-4.4},"uStepsZ_1706":{"type":"int","value":415},"uTFeedback_1710":{"type":"sampler2D","value":{"metadata":{"version":4.5,"type":"Texture","generator":"Texture.toJSON"},"uuid":"05d3beba-2715-4cc8-ac23-058c8d7d8756","name":"","image":"652cb7e2-9488-4f83-9c0b-bd71ee3e5ca9","mapping":300,"repeat":[1,1],"offset":[0,0],"center":[0,0],"rotation":0,"wrap":[1002,1002],"format":1023,"type":1009,"encoding":3000,"minFilter":1006,"magFilter":1006,"anisotropy":1,"flipY":false,"premultiplyAlpha":false,"unpackAlignment":4}},"uAdd_1750":{"type":"float","value":0.2},"uMult_1750":{"type":"float","value":-0.6},"uFrequency_1703":{"type":"float","value":0.6},"uAmplitude_1703":{"type":"float","value":20},"uPersistance_1703":{"type":"float","value":0.5},"uLacunarity_1703":{"type":"float","value":1.4},"uOctaves_1703":{"type":"int","value":3},"uExponent_1703":{"type":"float","value":4.4056},"uRidge_1703":{"type":"float","value":1},"uNormalize_1703":{"type":"bool","value":true},"uFrequency_1741":{"type":"float","value":0.2},"uAmplitude_1741":{"type":"float","value":20},"uPersistance_1741":{"type":"float","value":0.36},"uLacunarity_1741":{"type":"float","value":2},"uOctaves_1741":{"type":"int","value":5},"uExponent_1741":{"type":"float","value":0.3097},"uRidge_1741":{"type":"float","value":0.87013},"uNormalize_1741":{"type":"bool","value":true},"uOperation_1742":{"type":"int","value":2},"uSteps_1707":{"type":"int","value":10},"uAdd_1748":{"type":"float","value":0},"uMult_1748":{"type":"float","value":0.2},"uMin_1749":{"type":"float","value":-1},"uMax_1749":{"type":"float","value":1},"uFrequency_1703_1708":{"type":"float","value":0.5},"uAmplitude_1703_1708":{"type":"float","value":3.3},"uPersistance_1703_1708":{"type":"float","value":0.5},"uLacunarity_1703_1708":{"type":"float","value":1.4},"uOctaves_1703_1708":{"type":"int","value":3},"uExponent_1703_1708":{"type":"float","value":4.4056},"uRidge_1703_1708":{"type":"float","value":1},"uNormalize_1703_1708":{"type":"bool","value":true},"uOperation_1742_1742":{"type":"int","value":2},"uAngle2_1705":{"type":"float","value":0.816814089933347},"uX_1702":{"type":"float","value":0.1},"uY_1702":{"type":"float","value":0.2},"uZ_1702":{"type":"float","value":0.1},"uAmount_1702":{"type":"float","value":0.34},"uFrequency_1699":{"type":"float","value":200},"uXAmount_1699":{"type":"float","value":0},"uYAmount_1699":{"type":"float","value":-1},"uZAmount_1699":{"type":"float","value":0.46},"uMin_1699":{"type":"float","value":0},"uMax_1699":{"type":"float","value":1},"uPower_1699":{"type":"float","value":0.5095},"uFrequency_1699_1699":{"type":"float","value":200},"uXAmount_1699_1699":{"type":"float","value":1},"uYAmount_1699_1699":{"type":"float","value":0},"uZAmount_1699_1699":{"type":"float","value":0},"uMin_1699_1699":{"type":"float","value":-1},"uMax_1699_1699":{"type":"float","value":1},"uPower_1699_1699":{"type":"float","value":0.2098},"uOperation_1701":{"type":"int","value":0},"uAdd_1704":{"type":"float","value":2},"uMult_1704":{"type":"float","value":-2},"uContrast_1745":{"type":"float","value":0.62},"uBrightness_1745":{"type":"float","value":1},"uAmount_1711":{"type":"float","value":0.01},"uOperation_1751":{"type":"int","value":4},"uDithering_1695":{"type":"float","value":0},"uScale_1695":{"type":"float","value":0.002},"uSpeedX_1695":{"type":"float","value":0},"uSpeedY_1695":{"type":"float","value":0},"uSpeedZ_1695":{"type":"float","value":0.66},"uDitheringTextureDimensions_1695":{"type":"vec2","value":{"x":128,"y":128}},"uTDithering_1695":{"type":"sampler2D","value":{"metadata":{"version":4.5,"type":"Texture","generator":"Texture.toJSON"},"uuid":"13ecc519-88da-42c4-a171-e4b40a68df34","name":"","image":"6eabd10e-2fd2-49d5-84f9-889d4362d3ef","mapping":300,"repeat":[1,1],"offset":[0,0],"center":[0,0],"rotation":0,"wrap":[1000,1000],"format":1023,"type":1009,"encoding":3000,"minFilter":1003,"magFilter":1003,"anisotropy":1,"flipY":true,"premultiplyAlpha":false,"unpackAlignment":4}}},"readme":"\n  # Substrate export\n  A substrate export consists of a few things:\n  * vertex shader code\n  * fragment shader code\n  * this README\n  * a set of uniforms\n  * associated data, such as images\n  \n  The fragment shader and vertex shader are regular GLSL. Create a THREE.js shader material and use as you would with any shader material. However, keep in mind that you need to set the uniforms appropriately.\n\n  The uniforms object contains all the values set as the program was exported. These should be set when the material is created. Something like `material.uniforms = JSON.parse(exportData).uniforms` should work.\n\n  Keep in mind that this does not work for images or feedback nodes. Image data can be included in the data object, base64 encoded. You have to manually create textures and set these to the correct uniforms. Feedback nodes are a bit more difficult. For this to work, set up multiple framebuffers and alternate renders between them. Assign the passive framebuffer texture to the feedback uniforms. \n\n  The viewport uniform should be set to the current size of the canvas. The time uniform needs to be continuously updated for the shader to animate.\n","data":{"encodedImages":{}}}